# 公共字段规范

## 1. 概述

为了统一项目中所有实体类的字段结构和行为，我们定义了`BaseEntity`抽象类作为所有实体类的基类。该基类包含了一系列公共字段，用于记录实体的基本信息，如创建时间、更新时间、删除状态等。同时，通过easy-query框架的拦截器机制，实现了这些公共字段的自动管理，减少了重复代码，提高了开发效率。

## 2. BaseEntity公共字段

### 2.1 字段定义

```java
@Data
public abstract class BaseEntity implements Serializable, Cloneable {

    @Serial
    private static final long serialVersionUID = -1L;

    /**
     * 主键ID，使用UUIDv7算法
     */
    @Column(primaryKey = true, primaryKeyGenerator = UUIDPrimaryKeyGenerator.class)
    private UUID id;

    /**
     * 逻辑删除标志：是否删除，默认值为false
     * 逻辑删除时，还要处理deletedAt和deletedBy，所以使用自定义策略 {@link DefaultLogicDeleteStrategy}
     */
    @LogicDelete(strategy = LogicDeleteStrategyEnum.CUSTOM, strategyName = "DEFAULT_LOGIC_DELETE_STRATEGY")
    @UpdateIgnore
    private boolean isDeleted = false;

    /**
     * 删除时间，UTC时间戳
     */
    @UpdateIgnore
    private OffsetDateTime deletedAt;

    /**
     * 删除人ID
     */
    @UpdateIgnore
    private UUID deletedBy;

    /**
     * 创建时间，UTC时间戳
     */
    @UpdateIgnore
    private OffsetDateTime createdAt;
    
    /**
     * 创建人ID
     */
    @UpdateIgnore
    private UUID createdBy;
    
    /**
     * 更新时间，UTC时间戳
     */
    private OffsetDateTime updatedAt;
    
    /**
     * 更新人ID
     */
    private UUID updatedBy;

    /**
     * 版本号，用于乐观锁，默认值为0，每更新一次+1
     */
    @Version(strategy = VersionIntStrategy.class)
    private int version;

    @Override
    public BaseEntity clone() {
        try {
            BaseEntity clone = (BaseEntity) super.clone();
            // TODO: 复制此处的可变状态，这样此克隆就不能更改初始克隆的内部项
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}
```

### 2.2 字段详细说明

| 字段名 | 数据库列名 | 类型 | 含义 | 默认值 | 注解 | 作用 |
|-------|-----------|------|------|-------|------|------|
| id | id | UUID | 主键ID | 自动生成UUIDv7 | @Column(primaryKey = true, primaryKeyGenerator = UUIDPrimaryKeyGenerator.class) | 唯一标识实体记录 |
| isDeleted | is_deleted | boolean | 逻辑删除标志 | false | @LogicDelete(strategy = LogicDeleteStrategyEnum.CUSTOM, strategyName = "DEFAULT_LOGIC_DELETE_STRATEGY")<br>@UpdateIgnore | 标记记录是否被逻辑删除 |
| deletedAt | deleted_at | OffsetDateTime | 删除时间 | null | @UpdateIgnore | 记录逻辑删除的时间 |
| deletedBy | deleted_by | UUID | 删除人ID | null | @UpdateIgnore | 记录执行删除操作的用户ID |
| createdAt | created_at | OffsetDateTime | 创建时间 | null | @UpdateIgnore | 记录实体创建的时间 |
| createdBy | created_by | UUID | 创建人ID | null | @UpdateIgnore | 记录创建实体的用户ID |
| updatedAt | updated_at | OffsetDateTime | 更新时间 | null | - | 记录实体最后更新的时间 |
| updatedBy | updated_by | UUID | 更新人ID | null | - | 记录最后更新实体的用户ID |
| version | version | int | 版本号 | 0 | @Version(strategy = VersionIntStrategy.class) | 用于乐观锁，防止并发更新冲突，每更新一次自动+1 |

**说明**：
- **UUID类型**：使用`java.util.UUID`类型作为主键，通过`UUIDPrimaryKeyGenerator`生成UUIDv7，确保全局唯一性和时间有序性
- **OffsetDateTime类型**：所有时间字段使用`OffsetDateTime`类型，存储带时区的UTC时间戳，确保跨时区一致性
- **@UpdateIgnore注解**：标记字段在更新操作时忽略，避免被自动更新覆盖
- **@Version注解**：标记字段为版本号字段，用于乐观锁，通过`VersionIntStrategy`策略实现自动递增
- **默认值**：部分字段设置了默认值，如`isDeleted`默认为false，`version`默认为0

## 3. easy-query框架拦截器与公共字段

### 3.1 DefaultEntityInterceptor

`DefaultEntityInterceptor`实现了easy-query的拦截器接口，用于自动处理实体的创建和更新时间：

```java
@Component
@AllArgsConstructor(onConstructor_ = @Autowired)
public class DefaultEntityInterceptor implements EntityInterceptor, UpdateSetInterceptor, UpdateEntityColumnInterceptor {

    @Override
    public String name() {
        return "DEFAULT_INTERCEPTOR";
    }

    @Override
    public boolean apply(@NonNull Class<?> entityClass) {
        return BaseEntity.class.isAssignableFrom(entityClass);
    }

    @Override
    public void configureInsert(Class<?> entityClass, EntityInsertExpressionBuilder entityInsertExpressionBuilder, Object entity) {
        BaseEntity baseEntity = (BaseEntity) entity;

        OffsetDateTime now = OffsetDateTime.now();

        if (baseEntity.getCreatedAt() == null) {
            baseEntity.setCreatedAt(now);
        }
        if (baseEntity.getCreatedBy() == null) {
            // 可以在这里设置创建人ID
        }
        if (baseEntity.getUpdatedAt() == null) {
            baseEntity.setUpdatedAt(now);
        }
        if (baseEntity.getUpdatedBy() == null) {
            // 可以在这里设置更新人ID
        }
    }

    @Override
    public void configureUpdate(Class<?> entityClass, EntityUpdateExpressionBuilder entityUpdateExpressionBuilder, Object entity) {
        BaseEntity baseEntity = (BaseEntity) entity;
        baseEntity.setUpdatedAt(OffsetDateTime.now());
        // 可以在这里设置更新人ID
    }

    // 其他方法实现...
}
```

**功能说明**：
- **自动应用范围**：所有继承`BaseEntity`的实体类
- **insert操作**：自动设置`createTime`和`updateTime`为当前时间（如果为空）
- **update操作**：自动更新`updateTime`为当前时间
- **扩展点**：预留了设置`createBy`和`updateBy`的位置，可以集成用户认证系统获取当前用户ID

### 3.2 DefaultLogicDeleteStrategy

`DefaultLogicDeleteStrategy`实现了easy-query的逻辑删除策略接口，用于处理逻辑删除相关的字段：

```java
@Component
@RequiredArgsConstructor(onConstructor_ = @Autowired)
public class DefaultLogicDeleteStrategy extends AbstractLogicDeleteStrategy {
    @Override
    public String getStrategy() {
        return "DEFAULT_LOGIC_DELETE_STRATEGY";
    }

    @Override
    public Set<Class<?>> allowedPropertyTypes() {
        return Set.of(Boolean.class);
    }

    @Override
    protected SQLActionExpression1<WherePredicate<Object>> getPredicateFilterExpression(LogicDeleteBuilder builder, String propertyName) {
        return o->o.eq(propertyName, false);
    }

    @Override
    protected SQLActionExpression1<ColumnSetter<Object>> getDeletedSQLExpression(LogicDeleteBuilder builder, String propertyName) {
        return o->o.set(propertyName, true).set("deletedAt", OffsetDateTime.now());
    }
}
```

**功能说明**：
- **策略名称**：`DEFAULT_LOGIC_DELETE_STRATEGY`，与`BaseEntity`中`@LogicDelete`注解的`strategyName`对应
- **查询过滤器**：自动为查询操作添加`isDeleted = false`的条件，确保只查询未删除的记录
- **逻辑删除操作**：执行逻辑删除时，自动设置`isDeleted = true`和`deletedAt`为当前时间
- **扩展点**：预留了设置`deletedBy`的位置，可以集成用户认证系统获取当前用户ID

## 4. 工作流程

### 4.1 实体创建流程

1. 创建实体对象
2. 调用`save`方法保存实体
3. `UUIDPrimaryKeyGenerator`自动生成UUIDv7作为主键
4. `DefaultEntityInterceptor`自动设置`createdAt`和`updatedAt`为当前时间
5. 数据持久化到数据库

### 4.2 实体更新流程

1. 获取实体对象（包含当前版本号）
2. 修改实体属性
3. 调用`update`方法更新实体
4. `DefaultEntityInterceptor`自动更新`updatedAt`为当前时间
5. easy-query框架自动处理版本号：
   - 在WHERE条件中添加版本号匹配
   - 将版本号自动递增
6. 数据持久化到数据库

### 4.3 实体删除流程

1. 获取实体对象（包含当前版本号）
2. 调用`delete`方法删除实体
3. `DefaultLogicDeleteStrategy`自动执行逻辑删除：
   - 设置`isDeleted = true`
   - 设置`deletedAt`为当前时间
4. easy-query框架自动处理版本号：
   - 在WHERE条件中添加版本号匹配
   - 将版本号自动递增
5. 数据持久化到数据库

### 4.4 实体查询流程

1. 调用查询方法
2. `DefaultLogicDeleteStrategy`自动添加查询过滤器：`isDeleted = false`
3. 执行数据库查询，只返回未删除的记录

## 5. version乐观锁机制

### 5.1 工作原理

乐观锁是一种并发控制机制，通过版本号来检测并发更新冲突。其工作原理如下：

1. 当读取实体时，同时读取其版本号
2. 当更新实体时，将版本号作为WHERE条件的一部分
3. 更新操作同时将版本号递增
4. 如果在读取和更新之间，有其他线程修改了该实体，版本号会发生变化，导致更新操作失败

### 5.2 配置与实现

BaseEntity中version字段的配置：

```java
/**
 * 版本号，用于乐观锁，默认值为0，每更新一次+1
 */
@Version(strategy = VersionIntStrategy.class)
private int version = 0;
```

**说明**：
- 使用`@Version`注解标记字段为版本号字段
- 使用`VersionIntStrategy`策略，实现版本号自动递增（每次+1）
- 默认值为0，新创建的实体版本号从0开始

### 5.3 使用示例

#### 5.3.1 实体更新示例

```java
// 1. 获取实体（包含版本号）
User user = easyQuery.queryable(User.class).where(o -> o.eq("username", "admin")).firstOrNull();
if (user != null) {
    // 2. 修改实体属性
    user.setEmail("new_admin@example.com");
    // 3. 更新实体
    try {
        long rows = easyQuery.update(user).executeRows();
        if (rows > 0) {
            // 更新成功
            System.out.println("更新成功，新的版本号：" + user.getVersion());
        } else {
            // 更新失败，可能是并发冲突
            System.out.println("更新失败，可能存在并发冲突");
        }
    } catch (Exception e) {
        // 处理异常
        System.out.println("更新异常：" + e.getMessage());
    }
}
```

#### 5.3.2 表达式更新示例

```java
// 使用withVersion指定版本号
long rows = easyQuery.updatable(User.class)
        .set(User::getEmail, "new_email@example.com")
        .withVersion(1) // 指定版本号
        .where(o -> o.eq(User::getUsername, "admin"))
        .executeRows();

if (rows > 0) {
    System.out.println("更新成功");
} else {
    System.out.println("更新失败，版本号不匹配");
}
```

### 5.4 乐观锁冲突处理

当发生乐观锁冲突时，通常的处理策略有：

1. **重试机制**：捕获异常后重新获取最新数据，重新尝试更新
2. **提示用户**：告知用户数据已被其他用户修改，请重新操作
3. **自动合并**：尝试自动合并用户的修改和其他用户的修改

### 5.5 注意事项

- **版本号类型**：使用int类型的版本号适用于大多数场景，对于更新非常频繁的实体，可以考虑使用long类型
- **表达式更新**：使用表达式更新时，需要显式指定`withVersion`，否则不会使用乐观锁
- **性能考虑**：乐观锁会增加数据库操作的复杂度，但避免了悲观锁的性能开销，适合并发冲突较少的场景
- **批量操作**：批量更新操作中，乐观锁的使用需要特别注意，确保版本号的正确处理

## 6. 代码示例

### 6.1 实体类继承示例

```java
@Data
@Table("user")
public class User extends BaseEntity {
    private String username;
    private String email;
    private String password;
    // 其他业务字段...
}
```

### 6.2 保存实体示例

```java
User user = new User();
user.setUsername("admin");
user.setEmail("admin@example.com");
user.setPassword("encrypted_password");
// 无需手动设置id、createTime、updateTime等字段
easyQuery.insert(user).executeRows();
// 此时user对象已自动设置了id、createTime、updateTime等字段
```

### 6.3 更新实体示例

```java
User user = easyQuery.queryable(User.class).where(o -> o.eq("username", "admin")).firstOrNull();
if (user != null) {
    user.setEmail("new_admin@example.com");
    // 无需手动设置updateTime字段
    easyQuery.update(user).executeRows();
    // 此时user对象的updateTime已自动更新
}
```

### 6.4 删除实体示例

```java
User user = easyQuery.queryable(User.class).where(o -> o.eq("username", "admin")).firstOrNull();
if (user != null) {
    // 执行逻辑删除
    easyQuery.delete(user).executeRows();
    // 此时user对象的isDeleted已设置为true，deleteTime已设置为当前时间
}
```

### 6.5 查询实体示例

```java
// 自动过滤已删除的记录
List<User> users = easyQuery.queryable(User.class).where(o -> o.like("username", "a%")).toList();
// 返回的users列表中只包含isDeleted = false的记录
```

## 7. 配置与依赖

### 7.1 依赖配置

项目使用了以下关键依赖：

- **easy-query**：ORM框架，提供了拦截器和逻辑删除功能
- **uuid-creator**：用于生成UUIDv7
- **Spring Boot**：提供了依赖注入和组件管理

### 7.2 组件注册

所有拦截器和策略类都使用了`@Component`注解，确保被Spring Boot自动扫描和注册：

- `UUIDPrimaryKeyGenerator`：主键生成器
- `DefaultEntityInterceptor`：实体拦截器
- `DefaultLogicDeleteStrategy`：逻辑删除策略

## 8. 最佳实践

1. **统一继承BaseEntity**：所有实体类都应继承`BaseEntity`，确保字段结构一致
2. **避免手动设置公共字段**：公共字段由拦截器自动处理，避免手动设置导致的不一致
3. **集成用户认证系统**：根据实际项目情况，集成用户认证系统，实现`createdBy`、`updatedBy`和`deletedBy`的自动设置
4. **合理使用版本号**：利用`version`字段实现乐观锁，防止并发更新冲突
5. **注意时区处理**：所有时间字段使用`OffsetDateTime`类型，确保跨时区一致性

## 9. 参考链接

- [easy-query文档 - 对象设计](https://www.easy-query.com/easy-query-doc/practice/configuration/entity.html)
- [easy-query文档 - 自定义主键](https://www.easy-query.com/easy-query-doc/adv/auto-key.html)
- [easy-query文档 - 乐观锁版本号](https://www.easy-query.com/easy-query-doc/adv/version.html)