# 基础模块组件的依赖注入

## 概述

在 Spring Boot 多模块项目中，实现基础模块（如 `module-base`）的组件能够被上层模块（如 `module-business`）自动扫描注入是一个常见需求。本文档介绍了如何通过 Spring Boot 自动配置实现这一目标，并以 `PostgreSQLOffsetDateTimeTypeHandler` 为例说明具体实现。

## 实现方案

### 方案一：Spring Boot 自动配置（推荐）

这是最标准、最符合 Spring 生态规范的方案，也是官方推荐的跨模块组件复用标准方案。

#### 核心步骤

1. **在基础模块中创建自动配置类**

   在 `module-base` 中创建配置类，指定要扫描的包：

   ```java
   @Configuration
   @ComponentScan("com.lonbon.cloud.base") // base模块的根包
   public class BaseAutoConfiguration {
   }
   ```

2. **创建 Spring Boot 自动配置文件**

   在 `module-base` 的 `resources` 下创建自动配置文件，让 Spring Boot 自动识别：

   - 路径：`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`
   - 内容：直接写自动配置类的全限定类名

   ```
   com.lonbon.cloud.base.config.BaseAutoConfiguration
   ```

3. **上层模块引入依赖**

   在 `module-business` 的 `pom.xml` 中引入 `module-base` 依赖，启动类无需任何修改，启动后自动扫描注入 base 组件。

#### 优势

- **解耦彻底**：上层模块仅需引入依赖，无需修改任何代码
- **符合规范**：是 Spring Boot 2.7+ 之后的官方标准扩展方式
- **扩展性强**：支持复杂配置、条件装配等
- **通用性好**：适配多个上层模块

### 方案二：上层模块启动类指定扫描包

直接在 `module-business` 的 Spring Boot 启动类上，通过 `@ComponentScan` 显式包含 base 模块的包。

```java
// 核心：basePackages包含【business自身包】+【base模块包】
@SpringBootApplication
@ComponentScan(basePackages = {"com.lonbon.cloud.business", "com.lonbon.cloud.base"})
public class BusinessApplication {
    public static void main(String[] args) {
        SpringApplication.run(BusinessApplication.class, args);
    }
}
```

### 方案三：自定义扫描包注解

若有多个基础模块，可自定义一个注解统一管理扫描包。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@SpringBootApplication
@ComponentScan(basePackages = {"com.lonbon.cloud.base", "com.lonbon.cloud.common", "com.lonbon.cloud.business"})
public @interface EnableMyAllModule {
}
```

上层模块启动类直接使用自定义注解替代 `@SpringBootApplication`：

```java
@EnableMyAllModule
public class BusinessApplication {
    public static void main(String[] args) {
        SpringApplication.run(BusinessApplication.class, args);
    }
}
```

## 方案比较

| 维度 | 方案一（自动配置） | 方案三（自定义 @EnableXXX） |
|------|-------------------|-----------------------------|
| 规范度 | 符合 SpringBoot 官方标准 | 企业内部场景化封装 |
| 模块解耦 | 彻底解耦，上层无感知 | 存在配置耦合，需显式标注 |
| 扩展性 | 强，支持复杂配置 / 条件装配 | 弱，仅能封装固定扫描包 |
| 通用性 | 高，适配多上层模块 | 低，仅适配固定模块组合 |
| 适用场景 | 通用基础模块、开源组件、多上层模块 | 企业内部固定多模块组合 |

## 实例：PostgreSQLOffsetDateTimeTypeHandler 的自动注入

### 实现步骤

1. **创建类型处理器**

   在 `module-base` 中创建 `PostgreSQLOffsetDateTimeTypeHandler` 类，用于处理 PostgreSQL 的 `timestamptz` 类型与 Java 的 `OffsetDateTime` 类型之间的映射：

   ```java
   package com.lonbon.cloud.base.handler;

   import com.easy.query.core.basic.jdbc.executor.internal.merge.result.StreamResultSet;
   import com.easy.query.core.basic.jdbc.executor.internal.props.JdbcProperty;
   import com.easy.query.core.basic.jdbc.types.EasyParameter;
   import com.easy.query.core.basic.jdbc.types.handler.JdbcTypeHandler;
   import com.easy.query.sql.starter.config.JdbcTypeHandlerReplaceConfigurer;
   import org.springframework.stereotype.Component;

   import java.sql.*;
   import java.time.OffsetDateTime;
   import java.time.ZoneOffset;
   import java.util.HashSet;
   import java.util.Set;

   /**
    * PostgreSQL timestamptz 类型与 Java OffsetDateTime 类型的处理器
    */
   @Component
   public class PostgreSQLOffsetDateTimeTypeHandler implements JdbcTypeHandler, JdbcTypeHandlerReplaceConfigurer {

       public static final PostgreSQLOffsetDateTimeTypeHandler INSTANCE = new PostgreSQLOffsetDateTimeTypeHandler();

       @Override
       public boolean replace() {
           return true;
       }

       @Override
       public Set<Class<?>> allowTypes() {
           Set<Class<?>> types = new HashSet<>();
           types.add(OffsetDateTime.class);
           return types;
       }

       @Override
       public Object getValue(JdbcProperty jdbcProperty, StreamResultSet streamResultSet) throws SQLException {
           Timestamp timestamp = streamResultSet.getTimestamp(jdbcProperty.getJdbcIndex());
           if (timestamp == null) {
               return null;
           }
           // 将 Timestamp 转换为 OffsetDateTime
           return timestamp.toInstant().atOffset(ZoneOffset.UTC);
       }

       @Override
       public void setParameter(EasyParameter parameter) throws SQLException {
           OffsetDateTime value = (OffsetDateTime) parameter.getValue();
           if (value == null) {
               parameter.getPs().setNull(parameter.getIndex(), Types.TIMESTAMP_WITH_TIMEZONE);
           } else {
               // 将 OffsetDateTime 转换为 Timestamp
               Timestamp timestamp = Timestamp.from(value.toInstant());
               parameter.getPs().setTimestamp(parameter.getIndex(), timestamp);
           }
       }
   }
   ```

2. **配置自动扫描**

   由于该类位于 `com.lonbon.cloud.base.handler` 包下，且使用了 `@Component` 注解，同时 `BaseAutoConfiguration` 配置了扫描 `com.lonbon.cloud.base` 包，因此该类会被自动扫描到并注入到 Spring 容器中。

3. **上层模块使用**

   上层模块（如 `module-business`）只需引入 `module-base` 依赖，即可自动使用 `PostgreSQLOffsetDateTimeTypeHandler` 进行类型转换，无需任何额外配置。

## 关键注意事项

1. **组件位置**：基础模块的组件（`@Component`/`@Service`/`@Repository`/`@Controller`/`@Configuration` 等）必须在指定的扫描包下，否则无法被识别。

2. **Mapper 接口**：若基础模块有 Mapper 接口（MyBatis），仅靠 `@ComponentScan` 不够，需额外在启动类加 `@MapperScan("com.lonbon.cloud.base.mapper")`，或在基础模块的自动配置类中统一配置 `@MapperScan`。

3. **依赖范围**：确保 `module-base` 的依赖在 `module-business` 中是 compile 范围（Maven 默认），避免打包时缺失 base 的类。

## 验证方式

启动上层模块后，在任意业务类中 `@Autowired` 注入基础模块的组件，若能正常启动且无 `NoSuchBeanDefinitionException`，则说明扫描注入成功。

## 总结

通过 Spring Boot 自动配置实现基础模块组件的自动扫描注入，是一种标准、规范、高效的实现方式。它不仅符合 Spring Boot「约定大于配置」的核心设计理念，也为多模块项目的组件复用提供了最佳实践。

对于 `PostgreSQLOffsetDateTimeTypeHandler` 这样的类型处理器，通过上述方式可以实现自动注入，使上层模块无需关心具体实现细节，只需专注于业务逻辑的开发。