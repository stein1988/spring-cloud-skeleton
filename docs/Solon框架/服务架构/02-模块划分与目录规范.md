# 模块划分与目录规范

## 1. 模块划分原则

### 1.1 领域驱动设计原则

- **领域划分**：按照业务领域划分模块，每个模块对应一个业务领域
- **边界清晰**：明确定义模块的职责边界，避免职责重叠
- **高内聚**：模块内部功能紧密相关，形成一个有机整体
- **低耦合**：模块间通过明确的接口通信，减少直接依赖
- **独立演进**：模块可以独立开发、测试和演进

### 1.2 模块划分维度

#### 1.2.1 按业务领域划分

- **用户领域**：用户管理、认证授权等
- **订单领域**：订单创建、订单管理等
- **产品领域**：产品管理、库存管理等
- **支付领域**：支付处理、交易记录等

#### 1.2.2 按层次划分

- **接口层**：对外暴露的 API 接口
- **应用层**：协调领域服务，处理业务流程
- **领域层**：核心业务逻辑和领域模型
- **基础设施层**：技术基础设施，如数据库访问、消息队列等

#### 1.2.3 按功能划分

- **核心业务模块**：直接实现业务功能的模块
- **公共模块**：提供通用功能的模块
- **支撑模块**：提供技术支撑的模块

## 2. 目录结构规范

### 2.1 根目录结构

```
project-root/                # 项目根目录
├── pom.xml                  # 父项目 POM 文件
├── module-gateway/          # 网关模块，处理请求路由和认证
│   ├── pom.xml              # 模块 POM 文件
│   └── src/                 # 源代码目录
├── module-common/           # 公共模块，包含工具类、通用配置等
│   ├── pom.xml
│   └── src/
├── module-base/             # 基础模块，包含基础服务和通用功能
│   ├── pom.xml
│   └── src/
├── module-user/             # 用户业务模块
│   ├── pom.xml
│   └── src/
├── module-order/            # 订单业务模块
│   ├── pom.xml
│   └── src/
├── module-product/          # 产品业务模块
│   ├── pom.xml
│   └── src/
└── docs/                    # 文档目录
```

### 2.2 模块内部目录结构

以 `module-user` 为例：

```
module-user/
├── pom.xml
└── src/
    ├── main/
    │   ├── java/            # Java 源代码
    │   │   └── com/         # 包名目录
    │   │       └── lonbon/  # 组织名目录
    │   │           └── cloud/ # 项目名目录
    │   │               └── user/ # 模块名目录
    │   │                   ├── api/ # 接口层，处理 HTTP 请求
    │   │                   ├── application/ # 应用服务层，协调领域服务
    │   │                   ├── domain/ # 领域层，包含实体和业务规则
    │   │                   └── infrastructure/ # 基础设施层，包含数据库访问等
    │   └── resources/       # 资源文件
    └── test/                # 测试代码
        └── java/
```

## 3. 命名规范

### 3.1 模块命名规范

- 前缀：`module-`
- 名称：使用小写字母，多个单词用连字符 `-` 连接
- 示例：`module-user`、`module-order`


### 3.2 包命名规范

- **基础包**：`com.lonbon.cloud`
- **模块包**：在基础包后添加模块名
  - 示例：`com.lonbon.cloud.domain`、`com.lonbon.cloud.user`
- **子包**：根据功能划分
  - 示例：`com.lonbon.cloud.domain.entity`、`com.lonbon.cloud.user.api`

### 3.3 类命名规范

- **实体类**：`{实体名}`，如 `User`、`Order`
- **仓储接口**：`{实体名}Repository`，如 `UserRepository`
- **服务接口**：`{服务名}Service`，如 `UserService`
- **服务实现**：`{服务名}ServiceImpl`，如 `UserServiceImpl`
- **控制器**：`{功能名}Controller`，如 `UserController`
- **配置类**：`{配置项}Config`，如 `DataSourceConfig`
- **DTO 类**：`{功能名}DTO`，如 `UserDTO`
- **VO 类**：`{功能名}VO`，如 `UserVO`

### 3.4 方法命名规范

- **查询方法**：`find{描述}`、`get{描述}`，如 `findUserById`、`getAllUsers`
- **创建方法**：`create{描述}`、`add{描述}`，如 `createUser`、`addOrder`
- **更新方法**：`update{描述}`，如 `updateUser`
- **删除方法**：`delete{描述}`，如 `deleteUser`
- **业务方法**：使用动词 + 名词形式，如 `processPayment`、`submitOrder`

### 3.5 变量命名规范

- **局部变量**：使用驼峰命名法，如 `userId`、`orderAmount`
- **成员变量**：使用驼峰命名法，如 `private String userName;`
- **常量**：使用全大写，多个单词用下划线 `_` 连接，如 `MAX_PAGE_SIZE`
- **参数**：使用驼峰命名法，如 `public User getUserById(Long userId)`

## 4. 依赖管理

### 4.1 依赖关系规范

- **依赖方向**：遵循从上到下的依赖方向
  - `module-gateway` → 各业务模块
  - 各业务模块 → `module-base`
  - 各业务模块 → `module-common`
  - `module-base` → `module-common`

- **依赖类型**：
  - `compile`：编译时和运行时都需要的依赖
  - `provided`：编译时需要，运行时由容器提供的依赖
  - `test`：仅测试时需要的依赖
  - `runtime`：仅运行时需要的依赖

### 4.2 依赖管理策略

- **父项目管理**：在父项目的 POM 文件中统一管理依赖版本
- **依赖隔离**：避免模块间的隐式依赖
- **依赖分析**：定期分析依赖树，移除不必要的依赖
- **版本锁定**：使用 `<dependencyManagement>` 锁定依赖版本

### 4.3 避免循环依赖

- **依赖检查**：使用 Maven 或 Gradle 的依赖分析工具检查循环依赖
- **接口隔离**：通过接口定义模块间的通信方式，避免直接依赖实现
- **依赖倒置**：高层模块不依赖低层模块，而是依赖抽象

## 5. 代码组织

### 5.1 领域层代码组织

```
domain/
├── entity/          # 实体类
│   ├── User.java
│   └── Order.java
├── repository/      # 仓储接口
│   ├── UserRepository.java
│   └── OrderRepository.java
├── service/         # 领域服务
│   ├── UserService.java
│   └── OrderService.java
└── valueobject/     # 值对象
    ├── Address.java
    └── Money.java
```

### 5.2 应用层代码组织

```
application/
├── command/         # 命令对象
│   ├── CreateUserCommand.java
│   └── UpdateOrderCommand.java
├── query/           # 查询对象
│   ├── UserQuery.java
│   └── OrderQuery.java
├── service/         # 应用服务
│   ├── UserApplicationService.java
│   └── OrderApplicationService.java
└── dto/             # 数据传输对象
    ├── UserDTO.java
    └── OrderDTO.java
```

### 5.3 接口层代码组织

```
api/
├── controller/      # 控制器
│   ├── UserController.java
│   └── OrderController.java
├── vo/              # 视图对象
│   ├── UserVO.java
│   └── OrderVO.java
└── filter/          # 过滤器
    ├── AuthFilter.java
    └── LogFilter.java
```

### 5.4 基础设施层代码组织

```
infrastructure/
├── repository/      # 仓储实现
│   ├── UserRepositoryImpl.java
│   └── OrderRepositoryImpl.java
├── mapper/          # MyBatis 映射器
│   ├── UserMapper.java
│   └── OrderMapper.java
├── datasource/      # 数据源配置
│   └── DataSourceConfig.java
└── message/         # 消息队列
    └── MessageProducer.java
```

## 6. 配置管理

### 6.1 配置文件结构

```
resources/
├── app.yml          # 服务基础配置
├── app-dev.yml      # 开发环境配置
├── app-test.yml     # 测试环境配置
├── app-prod.yml     # 生产环境配置
└── bootstrap.yml    # 启动配置（用于加载配置中心配置）
```

### 6.2 配置项命名规范

- **使用小写字母**：配置项名称使用小写字母
- **使用点分隔**：多层级配置使用点 `.` 分隔
- **使用短横线**：多个单词使用短横线 `-` 连接
- **示例**：`spring.datasource.url`、`server.port`

### 6.3 配置管理最佳实践

- **集中管理**：使用配置中心（如 Nacos、Apollo）集中管理配置
- **环境隔离**：不同环境使用不同的配置文件
- **敏感信息保护**：敏感信息（如密码、密钥）使用加密存储
- **配置版本控制**：对配置文件进行版本控制
- **配置变更审计**：记录配置变更历史

## 7. 测试组织

### 7.1 测试目录结构

```
src/
├── main/            # 主代码
└── test/            # 测试代码
    ├── java/        # 测试源代码
    │   ├── unit/    # 单元测试
    │   ├── integration/ # 集成测试
    │   └── e2e/     # 端到端测试
    └── resources/   # 测试资源文件
```

### 7.2 测试命名规范

- **单元测试**：`{被测试类名}Test.java`，如 `UserServiceTest.java`
- **集成测试**：`{被测试类名}IntegrationTest.java`，如 `UserRepositoryIntegrationTest.java`
- **端到端测试**：`{功能名}E2ETest.java`，如 `UserRegistrationE2ETest.java`

### 7.3 测试覆盖范围

- **单元测试**：覆盖核心业务逻辑和工具类
- **集成测试**：覆盖模块间的集成和数据库操作
- **端到端测试**：覆盖完整的业务流程

### 7.4 测试最佳实践

- **测试驱动开发**：先编写测试，再实现功能
- **测试独立性**：测试用例之间相互独立，不依赖测试顺序
- **测试数据隔离**：每个测试用例使用独立的测试数据
- **测试覆盖率**：保持较高的测试覆盖率，重点覆盖核心功能
- **测试自动化**：集成到 CI/CD 流程中，实现自动化测试

## 8. 构建与部署

### 8.1 构建配置

- **Maven 配置**：在 POM 文件中配置构建参数
- **构建插件**：使用合适的 Maven 或 Gradle 插件
- **构建产物**：
  - 单体应用：生成一个可执行的 JAR 文件
  - 微服务：每个服务生成一个可执行的 JAR 文件

### 8.2 部署策略

- **单体应用部署**：
  - 传统部署：部署到物理机或虚拟机
  - 容器化部署：使用 Docker 容器部署

- **微服务部署**：
  - 容器化部署：使用 Docker 容器部署
  - 编排工具：使用 Kubernetes 进行服务编排
  - 服务网格：使用 Istio 等服务网格管理服务通信

### 8.3 持续集成与持续部署

- **CI/CD 流程**：
  1. 代码提交触发构建
  2. 执行自动化测试
  3. 构建 Docker 镜像
  4. 部署到测试环境
  5. 执行集成测试
  6. 部署到生产环境

- **CI/CD 工具**：
  - Jenkins
  - GitLab CI
  - GitHub Actions
  - 阿里云效

## 9. 最佳实践

### 9.1 模块划分最佳实践

1. **基于领域驱动设计**：按照业务领域划分模块，确保模块边界清晰
2. **渐进式拆分**：从粗粒度模块开始，随着业务的发展逐步细拆
3. **模块大小适中**：模块既不要太大也不要太小，保持合理的粒度
4. **关注业务价值**：模块划分应服务于业务需求，而不是技术实现
5. **团队协作**：考虑团队结构和协作方式，合理划分模块

### 9.2 目录结构最佳实践

1. **一致性**：保持项目内目录结构的一致性
2. **清晰性**：目录结构应清晰明了，便于导航和理解
3. **可扩展性**：目录结构应具有良好的可扩展性，能够适应业务的发展
4. **标准化**：遵循业界标准和最佳实践
5. **自动化**：使用工具自动生成和维护目录结构

### 9.3 依赖管理最佳实践

1. **依赖最小化**：只引入必要的依赖，避免依赖膨胀
2. **版本统一**：在父项目中统一管理依赖版本
3. **依赖分析**：定期分析依赖树，识别和解决依赖冲突
4. **依赖隔离**：使用模块边界隔离依赖，避免依赖泄露
5. **依赖文档**：文档化重要依赖的用途和版本选择理由

### 9.4 代码组织最佳实践

1. **分层清晰**：严格按照层次组织代码，避免层次混乱
2. **职责单一**：每个类和方法只负责一个功能
3. **代码整洁**：保持代码整洁，遵循代码规范
4. **文档完备**：为重要的类、方法和接口添加文档注释
5. **代码复用**：提取通用功能到公共模块，避免代码重复

### 9.5 配置管理最佳实践

1. **配置集中化**：使用配置中心集中管理配置
2. **环境隔离**：不同环境使用不同的配置，避免环境配置混淆
3. **配置加密**：对敏感配置进行加密处理
4. **配置验证**：在应用启动时验证配置的有效性
5. **配置变更管理**：建立配置变更的审批和发布流程

## 10. 总结

模块划分与目录规范是项目架构设计的重要组成部分，直接影响项目的可维护性、可扩展性和开发效率。通过基于领域驱动设计思想的模块划分，可以使系统结构更加清晰，模块职责更加明确，从而提高开发效率和代码质量。

在实际项目中，应根据业务需求、团队规模和技术栈等因素，灵活应用本文档中的规范和最佳实践，构建适合项目特点的模块结构和目录组织。同时，应保持对架构的持续优化，适应业务的发展和技术的演进。

通过合理的模块划分和目录规范，可以为项目的长期发展奠定坚实的基础，使系统更加健壮、可维护和可扩展。